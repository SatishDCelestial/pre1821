#pragma once

// Borland compatibility stuff
#define __FLAT__
#define __DLL__
//#ifndef _DEBUG
//#define _DLL 		// gets defined somewhere in debug builds
//#endif
#define __export __declspec(dllexport)

// the next section is from defs.h
//
// Commonly used fixed-size integer types
//
typedef signed char int8;
typedef signed short int16;
typedef signed long int32;

typedef unsigned char uint8;
typedef unsigned short uint16;
typedef unsigned long uint32;

//
// Some nonfixed-size types defined similar to the fixedsize in systypes.h
//
typedef unsigned long ulong;
typedef unsigned int uint;
typedef unsigned short ushort;
typedef unsigned char uchar;

// this section is from services/msc.h
//
//  C++ language features
//
//  When compiling with a compiler that doesn't support these
//  features directly, remove the // from the appropriate
//  #define below or define the macro in the build environment.
//

//
//  Language feature:          Description                  SERVICES header
//  ~~~~~~~~~~~~~~~~           ~~~~~~~~~~~~~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~
#define BI_NO_ARRAYNEW // operators new[] & delete[]   -
// sean #define BI_NO_BOOL          // Standard bool type           DEFS.H
#define BI_NO_COVAR_RET // Covariant returns in overrides -
#define BI_NO_MUTABLE   // Mutable keyword              DEFS.H
// sean #define BI_NO_NEW_CASTS     // New style casts              CASTABLE.H
#define BI_NO_NAMESPACE  // Namespaces
#define BI_NO_RTTI       // RTTI and __rtti keyword      DEFS.H
#define BI_NO_THROWSPEC  // Function throw specifiers    EXCEPT.H
#define BI_NO_LVAL_CASTS // Can cast lvalues

//
// Disable some MSC warnings, & move some to level 4 since they really are OK
//
#pragma warning(disable : 4068) // unknown pragma, compiler should ignore
#pragma warning(disable : 4514) // unreferenced inline, compiler internal noise
#pragma warning(disable : 4201) // complains about valid anonymouse unions!
#pragma warning(disable : 4355) // 'this' used in base member initializer list
#pragma warning(disable : 4250) // inherits <base> via dominance
// sean added the following - everything to the end
#pragma warning(disable : 4290) // C++ Exception Specification ignored
#pragma warning(disable : 4786) // identifiertruncated to 255 characters in debug info
#pragma warning(disable : 4097) // typedef-name used as synonym for class-name
#pragma warning(                                                                                                       \
    disable : 4516) // access-declarations are deprecated; member using-declarations provide a better alternative
#pragma warning(                                                                                                       \
    disable : 4239) // nonstandard extension - A reference that is not to const cannot be bound to a non-lvalue
#pragma warning(disable : 4100) // unreferenced formal parameter
#pragma warning(disable : 4291) // VC6: new - no matching operator delete found

// from defs.h
//----------------------------------------------------------------------------
//  These CAST macros encapsulate the new cast syntax in the ANSI/ISO
//  working paper. Note that TYPESAFE_DOWNCAST isn't as general as
//  dynamic_cast -- it only works on pointers.
//
//  Usage:
//
//  TYPESAFE_DOWNCAST(object,toClass)
//      Converts the pointer referred to by 'object' into a pointer to
//      an object of type 'toClass'. Note that the macro parameters to
//      TYPESAFE_DOWNCAST are in the opposite order from the rest of
//      the macros here. When using a compiler that supports new style
//      casts and runtime type information this is done with
//      dynamic_cast<> and will return 0 if the cast cannot be done.
//      When using a compiler that does not support new style casts and
//      runtime type information this is done with fake runtime type
//      information generated by the IMPLEMENT_CASTABLE macro.
//
//  STATIC_CAST(targetType,object)
//      Converts the data object referred to by 'object' into the type
//      referred to by 'targetType'. When using a compiler that supports
//      new style casts, this is done with static_cast<> and will fail
//      if the cast cannot be done without runtime type information.
//      When using a compiler that does not support new style casts, this
//      is done with an old style dangerous cast.
//
//  CONST_CAST(targetType,object)
//      Converts the data object referred to by 'object' into the type
//      referred to by 'targetType'. When using a compiler that supports
//      new style casts, this is done with const_cast<> and will fail
//      if the cast changes the type of the object in any way other than
//      adding or removing const and volatile qualifiers.
//      When using a compiler that does not support new style casts, this
//      is done with an old style dangerous cast.
//
//  REINTERPRET_CAST(targetType,object)
//      Converts the data object referred to by 'object' into the type
//      referred to by 'targetType'. When using a compiler that supports
//      new style casts, this is done with reinterpret_cast<>.
//      When using a compiler that does not support new style casts, this
//      is done with an old style dangerous cast.
//

#if defined(BI_NO_NEW_CASTS)
#define TYPESAFE_DOWNCAST(object, toClass) (object ? (toClass*)(object)->FindBase(#toClass) : 0)
#define STATIC_CAST(targetType, object) ((targetType)(object))
#define CONST_CAST(targetType, object) ((targetType)(object))
#define REINTERPRET_CAST(targetType, object) (*(targetType*)(void*)&(object))
#else
#define TYPESAFE_DOWNCAST(object, toClass) dynamic_cast<toClass*>(object)
#define STATIC_CAST(targetType, object) static_cast<targetType>(object)
#define CONST_CAST(targetType, object) const_cast<targetType>(object)
#define REINTERPRET_CAST(targetType, object) reinterpret_cast<targetType>(object)
#endif

// from services/private/defs.h
#define _RTLENTRY
#define _USERENTRY
#define _EXPCLASS
#define _EXPDATA

#define _EXPFUNC
#define _EXPFUNC32

#define _FAR
#define _FARFUNC
#define _FARCALL
#define _CLASSTYPE

#define _RTTI
#define _Cdecl
#define HUGE
#define __huge

#define _BIDSCLASS
#define _BIDSFAR
#define _BIDSFARDATA
#define _BIDSFARCLASS
#define _BIDSFUNC
#define _BIDSNEARFUNC
#define _OWLCLASS
#define _RTLENTRYF
#define _EXPFUNC16
#define _OWLCLASS_RTL
#define BI_PLAT_WIN32
#define _WSYSCLASS
#define _WSYSFUNC
#define BI_PLAT_MSW
#define BI_COMP_MSC

#ifndef _NPOS_DEFINED
#define _NPOS_DEFINED
// const size_t NPOS = size_t(-1);
#include "npos.h"
#endif
